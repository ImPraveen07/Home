<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Art Gallery Pro - God Mode Edition (Smoother)</title>
    <style>
        /* Base Styling */
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; touch-action: none; font-family: 'Georgia', serif; user-select: none; -webkit-user-select: none; }
        
        /* DEBUG CONSOLE */
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%;
            background: rgba(255,255,255,0.8); color: #333; font-size: 12px;
            padding: 5px; pointer-events: none; z-index: 9999;
            white-space: pre-wrap; border-bottom: 1px solid #ccc;
        }

        /* LOGIN SCREEN */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #e9e9e9; z-index: 100; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        h1 { color: #333; text-shadow: 0 0 5px rgba(0,0,0,0.1); font-size: 32px; margin-bottom: 30px; text-align: center; font-family: 'Times New Roman', serif; }
        input { 
            padding: 15px; font-size: 18px; text-align: center; width: 280px;
            background: #fff; border: 1px solid #888; color: #333; border-radius: 5px; outline: none;
            font-family: Arial, sans-serif; margin-bottom: 15px;
        }
        button#join-btn { 
            padding: 15px 60px; background: #333; color: #fff; border: none; margin-top: 10px;
            font-weight: bold; font-size: 20px; cursor: pointer; border-radius: 5px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        /* HUD */
        #ui-layer { position: absolute; top: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 50; }
        #room-display { font-size: 14px; color: #555; background: rgba(255,255,255,0.7); padding: 5px 15px; border-radius: 15px; display: inline-block; border: 1px solid #ccc; }

        /* ACTION BUTTONS */
        .action-btn {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; font-size: 20px; font-weight: bold; color: #fff;
            background: #555; border: 4px solid #fff; border-radius: 50px;
            cursor: pointer; display: none; z-index: 60;
            box-shadow: 0 0 30px rgba(0,0,0,0.3); animation: pulse 1s infinite alternate;
            pointer-events: auto; /* Allow interaction */
        }
        #door-btn { background: #aa0000; box-shadow: 0 0 30px rgba(170,0,0,0.4); top: 50%; width: 250px; }
        #close-window-btn { background: #008080; box-shadow: 0 0 30px rgba(0,128,128,0.4); top: 75%; width: 250px; }

        @keyframes pulse { from { transform: translate(-50%,-50%) scale(1); } to { transform: translate(-50%,-50%) scale(1.1); } }

        /* CONTROLS - FLOATING JOYSTICK */
        #zone-move { position: absolute; bottom: 0; left: 0; width: 50%; height: 100%; z-index: 10; }
        #zone-look { position: absolute; bottom: 0; right: 0; width: 50%; height: 100%; z-index: 10; }
        
        /* Joystick UI */
        #joy-container {
            position: absolute; width: 120px; height: 120px; display: none; pointer-events: none; z-index: 20;
            transform: translate(-50%, -50%); 
        }
        #joy-base {
            width: 100%; height: 100%;
            border: 2px solid rgba(0, 0, 0, 0.3); border-radius: 50%; 
            background: rgba(0, 0, 0, 0.05);
        }
        #joy-stick {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(0, 0, 0, 0.6); border-radius: 50%; 
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <video id="skyVideo" loop playsinline style="display:none" preload="auto">
        <source src="sky.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

    <div id="debug-console">Gallery System Ready.</div>

    <div id="login-screen">
        <h1>ART GALLERY PRO - GOD MODE</h1>
        <input type="text" id="username" placeholder="ENTER VIEWER NAME" maxlength="10">
        <input type="number" id="room-code" placeholder="GALLERY ID (e.g. 1)" maxlength="5">
        <button id="join-btn">ENTER GALLERY</button>
    </div>

    <div id="ui-layer">
        <div id="timer" style="display: none;"></div> 
        <div id="room-display">OFFLINE</div>
    </div>

    <button id="door-btn" class="action-btn">ðŸšª OPEN DOOR</button>
    <button id="close-window-btn" class="action-btn" style="top: 75%;">ðŸªŸ CLOSE WINDOW</button>

    <div id="zone-move"></div>
    <div id="zone-look"></div>
    
    <div id="joy-container">
        <div id="joy-base"></div>
        <div id="joy-stick"></div>
    </div>

    <script type="importmap">
        { "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
            "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"
        }}
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { initializeApp } from 'firebase/app';
        import { getFirestore, collection, doc, setDoc, onSnapshot, updateDoc, deleteDoc, getDoc } from 'firebase/firestore'; 

        // 1. CONFIG
        const firebaseConfig = {
          apiKey: "AIzaSyBDBH0OI_4y2lhONsUwzla987CJdyqafPE",
          authDomain: "haij-7e2f3.firebaseapp.com",
          databaseURL: "https://haij-7e2f3-default-rtdb.asia-southeast1.firebasedatabase.app",
          projectId: "haij-7e2f3",
          storageBucket: "haij-7e2f3.firebasestorage.app",
          messagingSenderId: "1071439646863",
          appId: "1:1071439646863:web:5dc1650e1dabbe9de0e0fa",
          measurementId: "G-CXVGW0NMLP"
        };

        const logDiv = document.getElementById('debug-console');
        function log(msg) { console.log(msg); logDiv.innerText = "> " + msg; }

        let db;
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            log("Firebase Initialized.");
        } catch(e) { log("CONFIG ERROR: Firebase initialization failed: " + e.message); }

        // 2. VARIABLES
        const myId = 'player_' + Math.floor(Math.random() * 999999); 
        let myName = "Viewer";
        let roomCode = "0";
        let isPlaying = false;
        let otherPlayers = {}; 
        let myPlayerMesh = null; // FIX: Variable to hold the local player's mesh
        
        // **GOD MODE CONFIG**
        const GOD_NAME = "Praveen"; // The name that gets the special character
        const GOD_COLOR = 0xffa500; // Orange/Gold for divine glow
        const REGULAR_COLOR = 0x888888;
        
        // **SMOOTHNESS CONFIG**
        const POSITION_UPDATE_INTERVAL = 50; // Faster update: 50ms
        const INTERPOLATION_FACTOR = 0.25;    // Quicker catch-up for smooth movement

        // Door State
        let isDoorOpen = false;
        let doorMesh; 
        const GAP_SIZE = 80; 
        const DOOR_THICKNESS = 4;
        const DOOR_WIDTH = GAP_SIZE; 
        const DOOR_HEIGHT = 120; 
        const DOOR_OPEN_POS = -DOOR_WIDTH; 
        const DOOR_CLOSED_POS = 0; 
        const DOOR_SPEED = 0.05; 
        // Collision constants
        const WALL_Z_POS = 0; 
        const PLAYER_RADIUS = 10; 
        const DOOR_LEFT_X = -(GAP_SIZE / 2); // -40
        const DOOR_RIGHT_X = (GAP_SIZE / 2); // 40

        const floorY = -50;

        // Window Control Variables
        let isWindowClosed = false;
        let windowGlassMesh;
        const CLOSE_SPEED = 0.005; 
        const GLASS_START_X = -30; 
        const GLASS_CLOSED_X = 0; 
        let windowCloseBtn = document.getElementById('close-window-btn');


        // 3. SCENE SETUP
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        scene.fog = new THREE.Fog(0xf0f0f0, 10, 800); 

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Lights
        const ambLight = new THREE.AmbientLight(0xffffff, 1.0); scene.add(ambLight);
        const pLight = new THREE.PointLight(0xffffff, 1.2, 800); pLight.position.set(0, 100, 0); scene.add(pLight); 

        // 4. TEXTURES & MATERIALS
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8, metalness: 0.0 });
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.6, metalness: 0.1 });
        const ceilingMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8, metalness: 0.0 });
        const wallMatInterior = new THREE.MeshStandardMaterial({ color: 0xddeeff, roughness: 0.8, metalness: 0.0, side: THREE.DoubleSide }); 
        
        const closedWindowGlassMat = new THREE.MeshPhysicalMaterial({ 
            color: 0xeeeeff, transparent: true, opacity: 0.2, metalness: 0.05,
            roughness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0.1, side: THREE.DoubleSide 
        }); 
        
        const transparentGlassMat = new THREE.MeshStandardMaterial({ 
            color: 0xeeeeff, transparent: true, opacity: 0.001, side: THREE.DoubleSide, depthWrite: false 
        });
        
        const curtainMat = new THREE.MeshStandardMaterial({ color: 0xcac7b8, roughness: 0.8, side: THREE.DoubleSide }); 

        // 5. VIDEO TEXTURE SETUP 
        const video = document.getElementById('skyVideo');
        video.volume = 0.0; 

        const videoTexture = new THREE.VideoTexture(video);
        // ** FIX 2: Optimized Texture Filtering for performance/lag **
        videoTexture.minFilter = THREE.NearestFilter;
        videoTexture.magFilter = THREE.NearestFilter;
        videoTexture.format = THREE.RGBAFormat;
        videoTexture.wrapS = THREE.ClampToEdgeWrapping; 
        videoTexture.wrapT = THREE.ClampToEdgeWrapping; 

        const VIDEO_ASPECT = 16 / 9;
        const W = 800; // Total Width
        const W_H = 125; // Window height 
        const W_W = 230; // Window width (approx)
        
        const GEOMETRY_ASPECT = (W_W * 2) / (W_H * 2); 
        const V_REPEAT_FACTOR = GEOMETRY_ASPECT / VIDEO_ASPECT;
        videoTexture.repeat.set(1.0, V_REPEAT_FACTOR);
        videoTexture.offset.set(0.0, (1 - V_REPEAT_FACTOR) / 2);

        const unlitVideoMat = new THREE.MeshBasicMaterial({ 
            map: videoTexture, 
            side: THREE.FrontSide, 
            fog: false
        });
        
        // 6. BUILD ROOM 
        const galleryObjects = []; 
        
        const H=800; // Total Depth
        const T=200; // Room/Wall Height
        const maxPos = W/2 - 10; 

        const CEILING_Y = floorY + T; 
        const WALL_CENTER_Y = floorY + T/2; 
        
        // --- WINDOW CONFIG ---
        const W_D = 30; 
        const BACK_Z = -400; // Z-position of the back wall


        // --- CUSTOM WALL BUILDER FOR BAY WINDOW CUTOUT ---
        function buildWallWithCutout(w, h, pz) {
            const windowStart = -W_W/2; 
            const windowEnd = W_W/2; 
            const windowBottom = floorY + 30; 
            const windowTop = floorY + 30 + W_H; 

            const WALL_CENTER_Y = floorY + T/2; 

            const wallGroup = new THREE.Group();
            wallGroup.position.set(0, WALL_CENTER_Y, pz);

            // Left wall segment
            const leftW = w/2 + windowStart;
            const leftH = h;
            const leftMesh = new THREE.Mesh(new THREE.PlaneGeometry(leftW, leftH), wallMat);
            leftMesh.position.x = windowStart - leftW/2;
            wallGroup.add(leftMesh); galleryObjects.push(leftMesh);

            // Right wall segment
            const rightW = w/2 - windowEnd;
            const rightH = h;
            const rightMesh = new THREE.Mesh(new THREE.PlaneGeometry(rightW, rightH), wallMat);
            rightMesh.position.x = windowEnd + rightW/2;
            wallGroup.add(rightMesh); galleryObjects.push(rightMesh);

            // Top beam
            const topH = h - (windowTop - windowBottom);
            const topYOffset = windowTop + (topH / 2) - WALL_CENTER_Y;
            const topMesh = new THREE.Mesh(new THREE.PlaneGeometry(windowEnd - windowStart, topH), wallMat);
            topMesh.position.y = topYOffset;
            wallGroup.add(topMesh); galleryObjects.push(topMesh);

            // Bottom support (Wall below the cutout)
            const bottomH = windowBottom - floorY;
            const bottomYOffset = windowBottom - bottomH/2 - WALL_CENTER_Y;
            const bottomMesh = new THREE.Mesh(new THREE.PlaneGeometry(windowEnd - windowStart, bottomH), wallMat);
            bottomMesh.position.y = bottomYOffset;
            wallGroup.add(bottomMesh); galleryObjects.push(bottomMesh);
            
            scene.add(wallGroup);
        }


        // --- Standard Wall Builder ---
        function buildWallGroup(w, h, px, py, pz, rx, ry, material) {
            const g = new THREE.Group();
            g.position.set(px, py, pz);
            g.rotation.set(rx, ry, 0);
            
            const m = new THREE.Mesh(new THREE.PlaneGeometry(w, h), material);
            g.add(m); 
            galleryObjects.push(m);
            scene.add(g);
        }

        // --- GALLERY BUILD ---
        const HALF_W = W/2;
        const HALF_H = H/2;
        
        // Floor (Y=-50)
        buildWallGroup(W,H, 0,-50,0, -Math.PI/2,0, floorMat); 
        
        // CEILING 
        function createCeiling() {
            const geometry = new THREE.PlaneGeometry(W, H, 10, 10); 
            const mesh = new THREE.Mesh(geometry, ceilingMat); 
            mesh.position.set(0, CEILING_Y, 0); 
            mesh.rotation.x = Math.PI / 2;
            scene.add(mesh); galleryObjects.push(mesh);
        }
        createCeiling();
        
        // Walls
        buildWallWithCutout(W,T, BACK_Z);
        createBayWindowScene(); 
        buildWallGroup(W,T, 0,WALL_CENTER_Y,HALF_H, 0,Math.PI, wallMat);
        buildWallGroup(H,T, -HALF_W,WALL_CENTER_Y,0, 0,Math.PI/2, wallMat);
        buildWallGroup(H,T, HALF_W,WALL_CENTER_Y,0, 0,-Math.PI/2, wallMat);

        // --- CENTRAL DIVIDING WALL (Door) ---
        const wallHeight = T; 
        const wallSegmentWidth = HALF_W - GAP_SIZE/2; 
        const wallSegmentCenter = HALF_W/2 + GAP_SIZE/4; 
        
        buildWallGroup(wallSegmentWidth, wallHeight, -wallSegmentCenter, WALL_CENTER_Y, 0, 0, 0, wallMatInterior);
        buildWallGroup(wallSegmentWidth, wallHeight, wallSegmentCenter, WALL_CENTER_Y, 0, 0, 0, wallMatInterior);

        const frameHeight = wallHeight - DOOR_HEIGHT; 
        buildWallGroup(GAP_SIZE, frameHeight, 0, floorY + DOOR_HEIGHT + frameHeight/2, 0, 0, 0, wallMatInterior);

        const sleeveDepth = DOOR_THICKNESS + 2; 
        const sleeveLength = DOOR_WIDTH * 1.5; 
        
        const sleeveWallGeo = new THREE.BoxGeometry(2, wallHeight, sleeveDepth);
        const sleeveWall = new THREE.Mesh(sleeveWallGeo, wallMatInterior);
        sleeveWall.position.set(DOOR_LEFT_X - sleeveLength, WALL_CENTER_Y, 0); 
        scene.add(sleeveWall); galleryObjects.push(sleeveWall);

        const sleeveTopBottomGeo = new THREE.BoxGeometry(sleeveLength * 2, 2, sleeveDepth);
        
        const sleeveTop = new THREE.Mesh(sleeveTopBottomGeo, wallMatInterior);
        sleeveTop.position.set(DOOR_LEFT_X - sleeveLength + GAP_SIZE/2, floorY + DOOR_HEIGHT, 0); 
        scene.add(sleeveTop); galleryObjects.push(sleeveTop);
        
        const sleeveBottom = new THREE.Mesh(sleeveTopBottomGeo, wallMatInterior);
        sleeveBottom.position.set(DOOR_LEFT_X - sleeveLength + GAP_SIZE/2, floorY, 0); 
        scene.add(sleeveBottom); galleryObjects.push(sleeveBottom);
        
        const doorGeo = new THREE.BoxGeometry(DOOR_WIDTH, DOOR_HEIGHT, DOOR_THICKNESS + 0.1); 
        doorMesh = new THREE.Mesh(doorGeo, wallMatInterior); 
        doorMesh.position.set(DOOR_CLOSED_POS, floorY + DOOR_HEIGHT/2, 0); 
        scene.add(doorMesh);
        
        // 7. FURNITURE 
        function createFurniture() {
            const g = new THREE.Group();
            
            const pMat = new THREE.MeshStandardMaterial({color: 0x999999});
            
            // Pedestal 1
            const leg1 = new THREE.Mesh(new THREE.CylinderGeometry(3,3,30,16), pMat);
            leg1.position.set(0, floorY + 15, -200); g.add(leg1); galleryObjects.push(leg1);
            const top1 = new THREE.Mesh(new THREE.CylinderGeometry(35,35,2,32), pMat);
            top1.position.set(0, floorY + 30, -200); g.add(top1); galleryObjects.push(top1);
            const sculpture1 = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), new THREE.MeshStandardMaterial({color: 0xaa00aa, roughness: 0.1, metalness: 0.8}));
            sculpture1.position.set(0, floorY + 35, -200); g.add(sculpture1); galleryObjects.push(sculpture1);

            // Pedestal 2
            const leg2 = new THREE.Mesh(new THREE.CylinderGeometry(3,3,30,16), pMat);
            leg2.position.set(0, floorY + 15, 200); g.add(leg2); galleryObjects.push(leg2);
            const top2 = new THREE.Mesh(new THREE.CylinderGeometry(35,35,2,32), pMat);
            top2.position.set(0, floorY + 30, 200); g.add(top2); galleryObjects.push(top2);
            const sculpture2 = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), new THREE.MeshStandardMaterial({color: 0x00aaff, roughness: 0.1, metalness: 0.8}));
            sculpture2.position.set(0, floorY + 35, 200); g.add(sculpture2); galleryObjects.push(sculpture2);
            
            scene.add(g);
        }
        createFurniture(); 
        
        // --- BAY WINDOW SCENE 
        function createBayWindowScene() {
            const group = new THREE.Group();
            
            const VIEW_W = W_W * 1.5; 
            const VIEW_H = W_H * 1.5;

            // 1. EXTERNAL VIEW PLANE (The Video Screen)
            const viewPlaneGeo = new THREE.PlaneGeometry(VIEW_W, VIEW_H);
            const viewPlane = new THREE.Mesh(viewPlaneGeo, unlitVideoMat);
            viewPlane.position.set(0, WALL_CENTER_Y, BACK_Z - 5); 
            group.add(viewPlane);
            
            // 2. RECESS FRAME AND SILL
            const frameThickness = 5;
            const W_D_HALF = W_D / 2;
            const recessMat = wallMatInterior.clone();
            recessMat.color.set(0xdddddd); 

            // Recess Top
            const recessTop = new THREE.Mesh(new THREE.BoxGeometry(W_W, frameThickness, W_D), recessMat);
            recessTop.position.set(0, WALL_CENTER_Y + W_H/2 + frameThickness/2, BACK_Z - W_D_HALF);
            group.add(recessTop);

            // Recess Bottom/Sill 
            const sillDepth = W_D + 15;
            const sillMat = new THREE.MeshStandardMaterial({ color: 0xb5b5b5, roughness: 0.4 });
            const sill = new THREE.Mesh(new THREE.BoxGeometry(W_W + 10, 5, sillDepth), sillMat);
            sill.position.set(0, WALL_CENTER_Y - W_H/2 - 2, BACK_Z + sillDepth/2 - W_D);
            group.add(sill);
            
            // 3. CURTAINS 
            const curtainWidth = W_W * 0.4;
            const curtainHeight = T;
            
            // Left Curtain
            const cL = new THREE.Mesh(new THREE.PlaneGeometry(curtainWidth, curtainHeight), curtainMat);
            cL.position.set(-W_W/2 - curtainWidth/2 - 10, WALL_CENTER_Y, BACK_Z + 1); 
            group.add(cL);
            
            // Right Curtain
            const cR = new THREE.Mesh(new THREE.PlaneGeometry(curtainWidth, curtainHeight), curtainMat);
            cR.position.set(W_W/2 + curtainWidth/2 + 10, WALL_CENTER_Y, BACK_Z + 1);
            group.add(cR);
            
            // 4. INVISIBLE GLASS PLANE 
            const invisibleGlassGeo = new THREE.PlaneGeometry(W_W, W_H);
            const invisibleGlass = new THREE.Mesh(invisibleGlassGeo, transparentGlassMat);
            invisibleGlass.position.set(0, WALL_CENTER_Y, BACK_Z - 1); 
            group.add(invisibleGlass);
            

            // 5. ADVANCED SLIDING GLASS PANEL 
            const glassPanelWidth = W_W + 5; 
            const glassPanelHeight = W_H + 5; 
            const glassThickness = 5;
            
            windowGlassMesh = new THREE.Mesh(
                new THREE.BoxGeometry(glassPanelWidth, glassPanelHeight, glassThickness),
                closedWindowGlassMat
            );
            
            // Start position: Off to the side (open)
            windowGlassMesh.position.set(
                GLASS_START_X - glassPanelWidth, 
                WALL_CENTER_Y, 
                BACK_Z + 2 
            ); 
            
            group.add(windowGlassMesh);

            scene.add(group);
            galleryObjects.push(group);
        }


        // 8. PLAYER CREATION FUNCTIONS
        
        function createGodPlayer(name) {
            const playerGroup = new THREE.Group();
            
            // 1. God Body 
            const godMat = new THREE.MeshStandardMaterial({
                color: GOD_COLOR, 
                emissive: GOD_COLOR, 
                emissiveIntensity: 0.5, 
                roughness: 0.1, 
                metalness: 0.9 
            });
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(7, 25, 4, 8), godMat); 
            body.position.y = 0;
            playerGroup.add(body);

            // 2. God Particle Aura 
            const particleCount = 200;
            const particleGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color(GOD_COLOR);
            
            for (let i = 0; i < particleCount; i++) {
                const radius = 15 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                positions.push(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta) + 10, radius * Math.cos(phi));
                colors.push(color.r, color.g, color.b);
            }

            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const particleMat = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            const aura = new THREE.Points(particleGeo, particleMat);
            playerGroup.add(aura);
            
            // 3. God Name Tag
            const canvas = document.createElement('canvas'); 
            canvas.width=300; canvas.height=80;
            const ctx = canvas.getContext('2d'); 
            ctx.font="bold 40px Arial"; 
            ctx.fillStyle="#FFD700"; 
            ctx.strokeStyle="#000000";
            ctx.lineWidth=3;
            ctx.textAlign="center"; 
            ctx.strokeText(`âœ¨ ${name} âœ¨`, 150, 50); 
            ctx.fillText(`âœ¨ ${name} âœ¨`, 150, 50);

            const spriteMat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) });
            const nameTag = new THREE.Sprite(spriteMat);
            nameTag.position.y = 35; 
            nameTag.scale.set(30, 8, 1); 
            playerGroup.add(nameTag);
            
            playerGroup.userData.auraMesh = aura;

            return playerGroup;
        }

        function createStandardPlayer(p) {
            // Reusable function for standard player creation (non-God)
            const g = new THREE.Group();
            
            // ** FIX 3: Standard Player body (Capsule - same shape as God, just different material) **
            const b = new THREE.Mesh(new THREE.CapsuleGeometry(6,20,4,8), new THREE.MeshStandardMaterial({color:REGULAR_COLOR}));
            g.add(b);
            
            // Player name tag (Sprite)
            const c=document.createElement('canvas'); c.width=256; c.height=64;
            const ctx=c.getContext('2d'); ctx.font="bold 30px Arial"; ctx.fillStyle="#333"; ctx.textAlign="center"; ctx.fillText(p.name,128,40);
            const s=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c)}));
            s.position.y=25; 
            s.scale.set(20,5,1); 
            g.add(s);
            
            return g;
        }


        // 9. GAME LOGIC
        document.getElementById('join-btn').addEventListener('click', () => {
            const u = document.getElementById('username').value.trim();
            const r = document.getElementById('room-code').value.trim();
            if(!u || !r) {
                 log("ERROR: Enter Name & Code");
                 return;
            }
            myName = u.charAt(0).toUpperCase() + u.slice(1); 
            roomCode = "room_" + r;
            document.getElementById('login-screen').style.display='none';
            document.getElementById('room-display').innerText=`GALLERY: ${r} ${myName === GOD_NAME ? '(GOD MODE)' : ''}`;
            isPlaying=true;
            
            // ** FIX 1: Removed `video.muted = true;` to enable immediate sound, relying on the click event **
            // Start playback - The click handles the autoplay policy, and volume is controlled by distance/window.
            video.play().catch(e => log("ERROR: Video playback failed. Check video path (sky.mp4) and ensure it's on a live server: " + e.message));

            // *** FIX 3 PART 1: Create the local player mesh but DO NOT add to scene ***
            const isMyPlayerGod = myName === GOD_NAME;
            if (isMyPlayerGod) {
                myPlayerMesh = createGodPlayer(myName);
            } else {
                myPlayerMesh = createStandardPlayer({ name: myName }); 
            }
            // scene.add(myPlayerMesh); // EXCLUDED so the local user doesn't see their own avatar.

            initMultiplayer();
        });


        async function initMultiplayer() {
            const roomRef = doc(db, "rooms", roomCode);
            const playersRef = collection(db, "rooms", roomCode, "players");

            try {
                const roomSnap = await getDoc(roomRef);
                if (!roomSnap.exists()) {
                    await setDoc(roomRef, { doorOpen: false });
                    log("Room document created successfully.");
                } else {
                     log("Room document exists.");
                }
            } catch (e) {
                log("FATAL ERROR: Could not create/check room document. Check Firestore Rules: " + e.message);
                return; 
            }
            
            // Room state listener (for door)
            onSnapshot(roomRef, (snap) => {
                const d = snap.data();
                if(d && d.doorOpen !== undefined && d.doorOpen !== isDoorOpen) {
                    isDoorOpen = d.doorOpen;
                    document.getElementById('door-btn').innerText = isDoorOpen ? "ðŸšª CLOSE DOOR" : "ðŸšª OPEN DOOR";
                }
            }, (error) => {
                log("Room listener error: " + error.message);
            });

            // Players listener
            onSnapshot(playersRef, (snap) => {
                const now = Date.now();
                const activePlayerIds = new Set();

                snap.forEach(d => {
                    const id = d.id;
                    const p = d.data();
                    
                    if(now - p.time > 10000) return; 
                    if(id === myId) return;

                    activePlayerIds.add(id);
                    const isGodPlayer = p.name === GOD_NAME;

                    if(!otherPlayers[id]) {
                        // ** FIX 3: Ensures other players are created correctly (God or Standard) **
                        const newPlayerMesh = isGodPlayer ? createGodPlayer(p.name) : createStandardPlayer(p);
                        
                        scene.add(newPlayerMesh);
                        otherPlayers[id] = { 
                            mesh: newPlayerMesh, 
                            tPos: new THREE.Vector3(p.x, p.y, p.z), 
                            tRot: p.ry, 
                            isGod: isGodPlayer
                        };
                        newPlayerMesh.position.set(p.x,p.y,p.z);
                    } else {
                        // Player exists, update target position
                        otherPlayers[id].tPos.set(p.x,p.y,p.z);
                        otherPlayers[id].tRot = p.ry;
                    }
                });
                
                // Cleanup disconnected players
                Object.keys(otherPlayers).forEach(id => {
                    if(!activePlayerIds.has(id)) { 
                        scene.remove(otherPlayers[id].mesh); 
                        delete otherPlayers[id]; 
                    }
                });
            }, (error) => {
                log("Players listener error: " + error.message);
            });

            // Position broadcast loop: **50ms interval for responsiveness**
            setInterval(() => {
                if(isPlaying) {
                    setDoc(doc(playersRef, myId), {
                        x:camera.position.x, 
                        y:camera.position.y-10, 
                        z:camera.position.z,
                        ry:camera.rotation.y, 
                        name:myName, 
                        time:Date.now()
                    }, { merge: true }).catch((e)=>{ 
                         console.warn("Update failed. Check Firestore Rules for /players/{playerId}:", e.message);
                    });
                }
            }, POSITION_UPDATE_INTERVAL); 
        }
        
        // --- INTERACTION LOGIC ---
        const doorBtn = document.getElementById('door-btn');
        doorBtn.addEventListener('click', () => {
            const newState = !isDoorOpen;
            updateDoc(doc(db, "rooms", roomCode), {doorOpen: newState})
                .then(() => {
                    log(`Door state updated to ${newState}`);
                })
                .catch((error) => { 
                    log("ERROR: Failed to update door state. Access Denied. Check Firestore Rules for /rooms/{roomId} 'update' permission."); 
                });
        });

        windowCloseBtn.addEventListener('click', () => {
            isWindowClosed = !isWindowClosed;
            windowCloseBtn.innerText = isWindowClosed ? "ðŸªŸ OPEN WINDOW" : "ðŸªŸ CLOSE WINDOW";
        });
        
        // --- JOYSTICK CONTROLS (Retained) ---
        let joyId=null, lookId=null;
        let move={x:0,y:0}, lastLook={x:0,y:0};
        
        const joyContainer = document.getElementById('joy-container');
        const joyStick = document.getElementById('joy-stick');
        let joyStart = {x:0, y:0};

        const zoneMove = document.getElementById('zone-move');
        zoneMove.addEventListener('touchstart', e => {
            e.preventDefault();
            if(joyId !== null) return;
            const touch = e.changedTouches[0];
            joyId = touch.identifier;
            joyStart = { x: touch.clientX, y: touch.clientY };
            joyContainer.style.display = 'block';
            joyContainer.style.left = touch.clientX + 'px';
            joyContainer.style.top = touch.clientY + 'px';
            joyStick.style.transform = `translate(-50%, -50%)`;
            move = {x:0, y:0};
        }, {passive:false});

        zoneMove.addEventListener('touchmove', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joyId) {
                    const t = e.changedTouches[i];
                    let dx = t.clientX - joyStart.x;
                    let dy = t.clientY - joyStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const maxDist = 60;
                    if(dist > maxDist) {
                        const ratio = maxDist / dist;
                        dx *= ratio;
                        dy *= ratio;
                    }
                    joyStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    move.x = dx / maxDist;
                    move.y = dy / maxDist;
                }
            }
        }, {passive:false});

        zoneMove.addEventListener('touchend', e => {
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joyId) {
                    joyId = null;
                    move = {x:0, y:0};
                    joyContainer.style.display = 'none';
                }
            }
        });

        const zoneLook = document.getElementById('zone-look');
        zoneLook.addEventListener('touchstart', e => {
            e.preventDefault();
            if(lookId !== null) return;
            const t = e.changedTouches[0];
            lookId = t.identifier;
            lastLook = {x: t.clientX, y: t.clientY};
        }, {passive:false});

        zoneLook.addEventListener('touchmove', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === lookId) {
                    const t = e.changedTouches[i];
                    const dx = t.clientX - lastLook.x;
                    const dy = t.clientY - lastLook.y;
                    camera.rotation.y -= dx * 0.004; 
                    camera.rotation.x -= dy * 0.004; 
                    camera.rotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, camera.rotation.x)); 
                    lastLook = {x: t.clientX, y: t.clientY};
                }
            }
        }, {passive:false});

        zoneLook.addEventListener('touchend', e => {
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === lookId) lookId = null;
            }
        });


        // --- ANIMATION ---
        camera.position.set(0,0,100);

        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                // ** FIX 2: Check video readiness for smoother performance **
                if (video.readyState >= video.HAVE_CURRENT_DATA) {
                    videoTexture.needsUpdate = true;
                }
            }

            // Door animation
            const targetXDoor = isDoorOpen ? DOOR_OPEN_POS : DOOR_CLOSED_POS; 
            doorMesh.position.x += (targetXDoor - doorMesh.position.x) * DOOR_SPEED;

            // Window animation
            const targetXGlass = isWindowClosed ? GLASS_CLOSED_X : (GLASS_START_X - windowGlassMesh.geometry.parameters.width); 
            const currentXGlass = windowGlassMesh.position.x;
            windowGlassMesh.position.x += (targetXGlass - currentXGlass) * CLOSE_SPEED;
            
            // Calculate closure ratio for volume
            const range = GLASS_CLOSED_X - (GLASS_START_X - windowGlassMesh.geometry.parameters.width);
            const relativePosition = windowGlassMesh.position.x - (GLASS_START_X - windowGlassMesh.geometry.parameters.width);
            let closureRatio = relativePosition / range;
            closureRatio = Math.max(0, Math.min(1, closureRatio));

            // Sound control
            const windowVolumeFactor = 1.0 - closureRatio;
            const SCREEN_Z_POS = BACK_Z; 
            const MAX_HEARING_DISTANCE = 600; 
            const MIN_DISTANCE_VOLUME_ONE = 20; 
            const distance = Math.abs(camera.position.z - SCREEN_Z_POS);

            let distanceVolumeFactor;
            if (distance <= MIN_DISTANCE_VOLUME_ONE) {
                distanceVolumeFactor = 1.0; 
            } else if (distance >= MAX_HEARING_DISTANCE) {
                distanceVolumeFactor = 0.0;
            } else {
                distanceVolumeFactor = 1.0 - (distance - MIN_DISTANCE_VOLUME_ONE) / (MAX_HEARING_DISTANCE - MIN_DISTANCE_VOLUME_ONE);
            }
            // ** FIX 1: Set video volume based on window position and player distance **
            video.volume = windowVolumeFactor * distanceVolumeFactor;

            // MOVEMENT & COLLISION 
            if(move.x!==0 || move.y!==0) {
                const oldX = camera.position.x;
                const oldZ = camera.position.z;

                const fwd = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), camera.rotation.y);
                const rgt = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), camera.rotation.y);
                
                const speed = 3.0; 
                camera.position.addScaledVector(fwd, -move.y * speed);
                camera.position.addScaledVector(rgt, move.x * speed);
                
                // Outer wall bounds 
                camera.position.x = Math.max(-maxPos, Math.min(maxPos, camera.position.x));
                camera.position.z = Math.max(-(HALF_H - PLAYER_RADIUS), Math.min(HALF_H - PLAYER_RADIUS, camera.position.z));
                
                // Central wall collision check (Z=0 wall)
                const playerZ = camera.position.z;
                const playerX = camera.position.x;
                
                if (Math.abs(playerZ - WALL_Z_POS) < PLAYER_RADIUS) {
                    const isOutsideDoorway = playerX < DOOR_LEFT_X || playerX > DOOR_RIGHT_X;
                    if (!isDoorOpen || isOutsideDoorway) { 
                        if (oldZ < WALL_Z_POS && playerZ > WALL_Z_POS) {
                            camera.position.z = WALL_Z_POS - PLAYER_RADIUS;
                        } else if (oldZ > WALL_Z_POS && playerZ < WALL_Z_POS) {
                            camera.position.z = WALL_Z_POS + PLAYER_RADIUS;
                        }
                    }
                }
            }

            // Button visibility logic
            const isNearDoor = camera.position.z > -150 && camera.position.z < 150 && camera.position.x > -100 && camera.position.x < 100 && isPlaying;
            const isNearWindow = camera.position.z < (BACK_Z + 100) && camera.position.x > -150 && camera.position.x < 150 && isPlaying;
            doorBtn.style.display = isNearDoor ? "block" : "none";
            windowCloseBtn.style.display = isNearWindow ? "block" : "none";


            // MULTIPLAYER ANIMATION - **SMOOTH LERPING**
            const time = Date.now() * 0.001;
            for(let id in otherPlayers) {
                const p = otherPlayers[id];
                p.mesh.position.lerp(p.tPos, INTERPOLATION_FACTOR); 
                p.mesh.rotation.y += (p.tRot - p.mesh.rotation.y)*INTERPOLATION_FACTOR;
                
                // GOD MODE AURA ANIMATION
                if (p.isGod) {
                    const aura = p.mesh.userData.auraMesh;
                    if (aura) {
                        aura.rotation.y = time * 0.5; 
                        aura.position.y = Math.sin(time * 3) * 1.5;
                    }
                }
            }

            document.getElementById('timer').style.display='none';

            renderer.render(scene, camera);
        }
        animate();

        // Cleanup on window close
        window.addEventListener('beforeunload', () => {
            if (roomCode !== "0" && myId) {
                deleteDoc(doc(db, "rooms", roomCode, "players", myId)).catch(()=>{});
            }
        });
    </script>
</body>
</html>
